---
sidebar_position: 1
---

# Quick Start ðŸ”¥

import { Header } from '@site/src/components/Header'

<Header />
<div align="center">
	<i>Of The VFQAT &#160;&#160;||&#160;&#160; By The VFQAT &#160;&#160;||&#160;&#160; For The VFQAT **</i>
</div>
<br />
<div align="center">
	<i>Time To End Firestore Types Madness</i>
</div>
<br />

\*\* Victim Of Firestore Quarter Ass Typing

:::danger

Documentation is still under development(English is hard!)

Not yet released, DO NOT install.

:::

## Installation

```bash
npm i firelordjs
```

:::caution

require Typescript 4.6.2+ and Firebase 9+

:::

:::info

The library size on disk is 300KB, the runtime code is at mere 2KB after minified and gzipped.

:::

## Typescript Configuration

```json title='tsconfig.json'
{   // ...other configs
	"compilerOptions": {
		// ...other options
		"strict": true, // compulsory
		"noUncheckedIndexedAccess": true, // optional
	},
}
```

## Define The Meta Type

```ts title='dataType.ts'
import { MetaTypeCreator, ServerTimestamp } from 'firelordjs'

export type Example = MetaTypeCreator<
	{
		a: number
		b: { c: boolean; d: { e: string }[] }
		f: { g: ServerTimestamp; h: 1010 | 2929 | 3838 }
	}, // can go with even more crazy looking data type, but not good for a quick tutorial
	'SomeCollectionName',
	string // document ID type, normally string
>
```

## Create Firelord References

```ts title='init.ts'
import { getFirelord } from 'firelordjs'
import { initializeApp } from 'firebase/app'
import { Example } from './dataType'

initializeApp({
	apiKey: '### FIREBASE API KEY ###',
	authDomain: '### FIREBASE AUTH DOMAIN ###',
	projectId: '### CLOUD FIRESTORE PROJECT ID ###',
})

const firelordRef = getFirelord()

export const example = firelordRef<Example>('SomeCollectionName')
```

## Operations

```ts title='operations.ts'
import { example } from './init'
import {
	getDoc,
	getDocs,
	setDoc,
	updateDoc,
	deleteDoc,
	addDoc,
	query,
	serverTimestamp,
	increment,
	arrayUnion,
	where,
	orderBy,
	onSnapshot,
	startAfter,
} from 'firelordjs'

await setDoc(example.doc('abc'), {
	a: 100,
	b: { c: true, d: [{ e: 'abc' }] },
	f: { g: serverTimestamp(), h: 1010 },
})

await addDoc(example.collection(), {
	a: 900,
	b: { c: false, d: [{ e: 'hi' }] },
	f: { g: serverTimestamp(), h: 3838 },
})

await updateDoc(example.doc('abc'), {
	a: increment(1),
	'b.d': arrayUnion({ e: 'hello' }), // dot notation form
	f: { h: 2929 }, // nested form
})

await deleteDoc(example.doc('abc'))

await getDoc(example.doc('abc')).then(docSnapshot => {
	const data = docSnapshot.data()
})

await getDocs(
	query(
		example.collection(),
		where('f.h', '>', 1010 as const),
		orderBy('f.h'),
		limit(10)
	)
)

const unsub = onSnapshot(
	query(
		example.collection(),
		where('b.d', 'array-contains', { e: 'hello' }),
		orderBy('f.g'),
		startAfter(new Date())
	),
	querySnapshot => {
		querySnapshot.forEach(docSnapshot => {
			const data = docSnapshot.data()
		})
	},
	{ includeMetadataChanges: false } // optional
)
```

## Batch

```ts title='batch.ts'
import { example } from './init'
import { writeBatch, serverTimestamp } from 'firelordjs'

const batch = writeBatch()

batch.set(example.doc('hij'), {
	a: 6,
	b: { c: false, d: [{ e: 'xyz' }] },
	f: { g: serverTimestamp(), h: 1010 },
})

batch.update(example.doc('hij'), {
	a: 6,
	b: { c: false }, // nested form
	'f.g': serverTimestamp(), // dot notation form
})

batch.delete(example.doc('hij'))

await batch.commit()
```

## Transaction

```ts title='transaction.ts'
import { example } from './init'
import {
	runTransaction,
	serverTimestamp,
	increment,
	arrayRemove,
} from 'firelordjs'

try {
	await runTransaction(async transaction => {
		await transaction.get(example.doc('lmn')).then(docSnapshot => {
			const data = docSnapshot.data()
		})

		transaction.set(example.doc('lmn'), {
			a: 88,
			b: { c: false, d: [{ e: 'opq' }] },
			f: { g: serverTimestamp(), h: 2929 },
		})

		transaction.update(example.doc('lmn'), {
			a: increment(1),
			b: { d: arrayRemove({ e: 'rst' }) }, // nested form
			'f.g': serverTimestamp(), // dot notation form
		})

		transaction.delete(example.doc('lmn'))
	})
	console.log('Transaction successfully committed!')
} catch (e) {
	console.log('Transaction failed: ', e)
}
```

## Did I Just Learned Everything In A Page?

Long answer: Almost, short answer: Yes.

FirelordJS API looks and feels nearly identical to the original Firestore SDK, to the point that in just one page, you have learned almost everything, equipped with **full fledged** type safety, effortlessly.

Every value is safely typed, this including collection ID, document ID, all operations, all field paths, all values, all query clauses, basically whatever FirelordJS exports.

FirelordJS infers types of every single value from the MetaType defined in the very beginning, and this is the only time you ever have to deal with the type, there is no need for type annotation and type casting, **type it and forget**.

This is done elegantly without complicated configuration while maintain API that is nearly identical to the original Firestore API, and simpler.
