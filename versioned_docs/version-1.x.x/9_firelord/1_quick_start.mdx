---
sidebar_position: 1
---

# Quick Start ðŸ”¥

import { Header } from '@site/src/components/FirelordHeader'

<Header />

Support [emulator](https://firelordjs.com/firelord/tests)

## Installation

```bash
npm i firebase-admin firelord@1
npm i -D typescript
```

:::caution

require Typescript 4.8.2+, firebase-admin 11+

:::

:::info

The library size on disk is 300KB, most of the code are type definitions and comments, the runtime code is at mere 8KB after minified and gzipped, [see how we got this number](/1.x.x/minified_size).

:::

:::tip
Firelord API is almost exactly as same as [FirelordJS](https://firelordjs.com/quick_start), which mean:

1. They share basically the same documentation, hence we will skip most of the documentation to avoid repetition.
2. They can also share data type definition.

On surface, only the installation process is different and we import from `firelord` instead of `firelordjs`.

:::

## Typescript Configuration

```json title='tsconfig.json'
{
	// ...other configs
	"compilerOptions": {
		// ...other options
		"strict": true, // compulsory
		// below options are optional, be sure to google what they do!
		"noUncheckedIndexedAccess": true, // optional but recommended
		"exactOptionalPropertyTypes": true
	}
}
```

## Define The Meta Type

Meta Type is your single source of truth.

```ts title='dataType.ts'
import { MetaTypeCreator, ServerTimestamp } from 'firelord'

export type Example = MetaTypeCreator<
	{
		a: number
		b: { c: boolean; d: { e: string }[] }
		f: { g: ServerTimestamp; h: 1010 | 2929 | 3838 }
	}, // can go with even more crazy looking data type
	'SomeCollectionName', // collection ID type, must be string literal type
	string // document ID type, normally string
>
```

## Create Firelord References

:::tip
After you created the Firelord Ref, you no longer need to write collection name in any operations.
:::

```ts title='init.ts'
import { getFirelord, getFirestore } from 'firelord'
import { initializeApp, cert, ServiceAccount } from 'firebase-admin/app'
import { Example } from './dataType'
// if you run in cloud function
const app = initializeApp()

// if you run in custom backend or you run in cloud function but want to access other project firestore
import serviceAccount from './serviceAccount.json' // get it from firebase console --> project setting --> service accounts, THIS IS A SECERT!
const app_ = initializeApp({
	credential: cert(serviceAccount as ServiceAccount),
})

export const db = getFirestore() // or getFirestore(app), you can skip this line

// Recommendation: Export this if the collection is sub-collection and then fill in collection path later, because sub collection most likely have dynamic document ID.
export const firelordExample = getFirelord<Example>() // or getFirelord<Example>(db)
// then call them using
// const example = firelordExample(`parentCollectionName/${someDocId}/SomeCollectionName`) // this is your firelordRef

// Recommendation: Export this if the collection is root collection
export const example = firelordExample('SomeCollectionName') // this is your firelordRef
```

## Operations

```ts title='operations.ts'
import { example } from './init'
import {
	getDoc,
	setDoc,
	updateDoc,
	deleteDoc,
	addDoc,
	serverTimestamp,
	increment,
	arrayUnion,
} from 'firelord'

await createDoc(example.doc('abc'), {
	a: 500,
	b: { c: true, d: [{ e: 'efg' }] },
	f: { g: serverTimestamp(), h: 2929 },
})

await setDoc(example.doc('abc'), {
	a: 100,
	b: { c: true, d: [{ e: 'abc' }] },
	f: { g: serverTimestamp(), h: 1010 },
})

await addDoc(example.collection(), {
	a: 900,
	b: { c: false, d: [{ e: 'hi' }] },
	f: { g: serverTimestamp(), h: 3838 },
})

await updateDoc(example.doc('abc'), {
	a: increment(1),
	'b.d': arrayUnion({ e: 'hello' }), // dot notation form
	f: { h: 2929 }, // nested form
})

await deleteDoc(example.doc('abc'))

await getDoc(example.doc('abc')).then(async docSnapshot => {
	// everything here is narrowly typed based on MetaType
	// ref.parent is recursively typed
	console.log(docSnapshot.data()) // { a: number; b: { c: boolean; d: { e: string; }[]; }; f: { g: Timestamp | null; h: 1010 | 2929 | 3838; }; | undefined
	console.log(docSnapshot.exists()) // boolean
	console.log(docSnapshot.get('b.c')) // arguments type is "a" | "b.c" | "b.d" | "f.g" | "f.h"
	console.log(docSnapshot.id) // string, based on documentId type

	console.log(docSnapshot.ref.firestore) // firestore instance
	console.log(docSnapshot.ref.id) // same as docSnapshot.id
	console.log(await docSnapshot.ref.listCollections()) // an array of CollectionReference<Example>
	console.log(docSnapshot.ref.path) // full path of this document, type is `SomeCollectionName/${string}`

	// parent of document is collection, parent of collection is document
	console.log(docSnapshot.ref.parent) // in this case, it is collection reference of this document
	console.log(docSnapshot.ref.parent.firestore) // firestore instance
	console.log(docSnapshot.ref.parent.id) // collectionId, type is `SomeCollectionName`
	console.log(await docSnapshot.ref.parent.listDocuments()) // an array of DocumentReference<Any>, NOTE: currently this is not possible to type, you need to type cast it
	console.log(docSnapshot.ref.parent.parent) // no more parent, null
	console.log(docSnapshot.ref.parent.path) // full path of this collection, type is `SomeCollectionName`
})
```

## Query And OnSnapshot

```ts
import { example } from './init'
import {
	getDocs,
	query,
	where,
	orderBy,
	onSnapshot,
	startAfter,
	limit,
} from 'firelord'

getDocs(
	query(
		example.collection(), // also accept example.collectionGroup()
		where('f.h', '>', 1010 as const),
		orderBy('f.h'),
		limit(10)
	)
).then(querySnapshot => {
	querySnapshot.docChanges().forEach(docChange => {
		// native forEach, has index
		console.log(docChange.doc) // return docSnapshot similar to docSnapshot of getDoc
		console.log(docChange.type) // 'added', 'modified', or 'removed'
		console.log(docChange.oldIndex) // number
		console.log(docChange.newIndex) //  number
		console.log(docChange.isEqual(docChange)) // boolean, compare with other docChange
	})
	querySnapshot.forEach(docSnapshot => {
		// forEach is not native forEach, it has no index
		// similar to docSnapshot of getDoc
	})
	querySnapshot.docs.forEach(docSnapshot => {
		// native forEach, has index
		// similar to docSnapshot of getDoc
	})
})

const unsub = onSnapshot(
	query(
		example.collectionGroup(), // also accept example.collection()
		where('b.d', 'array-contains', { e: 'hello' }),
		orderBy('f.g'),
		startAfter(new Date())
	),
	querySnapshot => {
		querySnapshot.forEach(docSnapshot => {
			// same as querySnapshot of getDocs
		})
	},
	error => {} // optional, onError callback
)
```

## Batch

```ts title='batch.ts'
import { example, db } from './init'
import { writeBatch, serverTimestamp } from 'firelord'

const batch = writeBatch(db)
// OR
const batch_Alt = writeBatch()

batch.create(example.doc('hij'), {
	a: 6,
	b: { c: true, d: [{ e: '123' }] },
	f: { g: serverTimestamp(), h: 2929 },
})

batch.set(example.doc('hij'), {
	a: 7,
	b: { c: false, d: [{ e: 'xyz' }] },
	f: { g: serverTimestamp(), h: 1010 },
})

batch.update(example.doc('hij'), {
	a: 8,
	b: { c: false }, // nested form
	'f.g': serverTimestamp(), // dot notation form
})

batch.delete(example.doc('hij'))

await batch.commit()
```

## Transaction

```ts title='transaction.ts'
import { example, db } from './init'
import {
	runTransaction,
	serverTimestamp,
	increment,
	arrayRemove,
} from 'firelord'

try {
	const result = await runTransaction(
		db, // db argument is optional, you can skip it
		async transaction => {
			await transaction.get(example.doc('lmn')).then(docSnapshot => {
				const data = docSnapshot.data()
			})

			transaction.create(example.doc('lmn'), {
				a: 500,
				b: { c: true, d: [{ e: 'efg' }] },
				f: { g: serverTimestamp(), h: 3838 },
			})

			transaction.set(example.doc('lmn'), {
				a: 88,
				b: { c: false, d: [{ e: 'opq' }] },
				f: { g: serverTimestamp(), h: 2929 },
			})

			transaction.update(example.doc('lmn'), {
				a: increment(1),
				b: { d: arrayRemove({ e: 'rst' }) }, // nested form
				'f.g': serverTimestamp(), // dot notation form
			})

			transaction.delete(example.doc('lmn'))

			return 123 // return this to result
		},
		{ readOnly: true, readTime: Timestamp.now() } // optional
		// we can supply 2 set of options:
		// 1. { readOnly?: false, maxAttempts?: number }
		// note that in case 1 both properties are optional and readOnly is false
		// 2. { readOnly: true, readTime?: Timestamp }
		// note that in case only readTime is optional and readOnly is true
	)

	console.log(result) // result is 123 because we return 123 in runTransaction callback
} catch (e) {
	console.log('Transaction failed: ', e)
}
```

To learn more, read the [Web](https://firelordjs.com/3_highlights/about) section.
